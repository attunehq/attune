package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"text/tabwriter"
	"time"

	"github.com/spf13/cobra"
)

func repoCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "repo",
		Short: "Manage repositories",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	createRepositoryCmd.Flags().StringP("uri", "u", "", "URI at which repository will be hosted")
	createRepositoryCmd.MarkFlagRequired("uri")
	createRepositoryCmd.Flags().StringP("distribution", "d", "", "OS distribution release name (e.g. \"bookworm\")")
	createRepositoryCmd.MarkFlagRequired("distribution")
	createRepositoryCmd.Flags().StringP("origin", "o", "", "")
	createRepositoryCmd.Flags().StringP("label", "l", "", "")
	createRepositoryCmd.Flags().StringP("version", "v", "", "")
	createRepositoryCmd.Flags().StringP("suite", "s", "", "")
	createRepositoryCmd.Flags().StringP("codename", "c", "", "")
	createRepositoryCmd.Flags().StringP("description", "e", "", "")

	statusRepositoryCmd.Flags().IntP("repo-id", "r", 0, "ID of the repository")
	statusRepositoryCmd.MarkFlagRequired("repo-id")

	cmd.AddCommand(createRepositoryCmd, listRepositoriesCmd, statusRepositoryCmd, repoSyncCmd(), repoPkgCmd())
	return cmd
}

type CreateRepositoryRequest struct {
	URI          string  `json:"uri"`
	Distribution string  `json:"distribution"`
	Origin       *string `json:"origin"`
	Label        *string `json:"label"`
	Version      *string `json:"version"`
	Suite        *string `json:"suite"`
	Codename     *string `json:"codename"`
	Description  *string `json:"description"`
}

var createRepositoryCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new repository",
	Long: `Create a new APT repository.

Repositories require a URI (at which they will be hosted) and a distribution
(such as "bookworm" for Debian or "noble" for Ubuntu). All other flags set
optional metadata fields for the repository's Release file.

For a detailed explanation of these fields, see:
https://wiki.debian.org/DebianRepository/Format#A.22Release.22_files`,
	Run: func(cmd *cobra.Command, args []string) {
		uri, err := cmd.Flags().GetString("uri")
		if err != nil {
			fmt.Printf("could not read --uri: %s\n", err)
			os.Exit(1)
		}
		distribution, err := cmd.Flags().GetString("distribution")
		if err != nil {
			fmt.Printf("could not read --distribution: %s\n", err)
			os.Exit(1)
		}
		origin := GetMaybeString(cmd, "origin")
		if origin == nil {
			origin = &distribution
		}
		label := GetMaybeString(cmd, "label")
		if label == nil {
			label = &distribution
		}
		version := GetMaybeString(cmd, "version")
		suite := GetMaybeString(cmd, "suite")
		if suite == nil {
			suite = &distribution
		}
		codename := GetMaybeString(cmd, "codename")
		if codename == nil {
			codename = &distribution
		}
		description := GetMaybeString(cmd, "description")
		if description == nil {
			v := "Generated by Attune"
			description = &v
		}
		reqBody := CreateRepositoryRequest{
			URI:          uri,
			Distribution: distribution,
			Origin:       origin,
			Label:        label,
			Version:      version,
			Suite:        suite,
			Codename:     codename,
			Description:  description,
		}

		jsonBody, err := json.Marshal(reqBody)
		if err != nil {
			fmt.Printf("could not marshal CreateRepositoryRequest: %s\n", err)
			os.Exit(1)
		}

		res, err := http.Post("http://localhost:3000/api/v0/repositories",
			"application/json",
			bytes.NewBuffer(jsonBody))
		if err != nil {
			fmt.Printf("could not create repository: %s\n", err)
			os.Exit(1)
		}
		defer res.Body.Close()

		if res.StatusCode != http.StatusOK {
			fmt.Printf("could not create repository: %s\n", res.Status)
			os.Exit(1)
		}

		var repository Repository
		if err := json.NewDecoder(res.Body).Decode(&repository); err != nil {
			fmt.Printf("could not decode repository: %s\n", err)
			os.Exit(1)
		}

		fmt.Println("Created new repository:")
		w := tabwriter.NewWriter(os.Stdout, 0, 8, 1, '\t', 0)
		fmt.Fprint(w, "ID\tURI\tDistribution\n")
		fmt.Fprintf(w, "%d\t%s\t%s\n", repository.ID, repository.URI, repository.Distribution)
		w.Flush()
	},
}

type Repository struct {
	ID           int
	URI          string
	Distribution string
}

var listRepositoriesCmd = &cobra.Command{
	Use:   "list",
	Short: "List repositories",
	Run: func(cmd *cobra.Command, args []string) {
		req, err := http.NewRequest(http.MethodGet, "/api/v0/repositories", nil)
		if err != nil {
			fmt.Printf("could not create request for listing repositories: %s\n", err)
			os.Exit(1)
		}
		res, err := API(req)
		if err != nil {
			fmt.Printf("could not list repositories: %s\n", err)
			os.Exit(1)
		}
		defer res.Body.Close()

		if res.StatusCode != http.StatusOK {
			fmt.Printf("could not list repositories: %s\n", res.Status)
			os.Exit(1)
		}

		var repositories []Repository
		if err := json.NewDecoder(res.Body).Decode(&repositories); err != nil {
			fmt.Printf("could not decode repositories: %s\n", err)
			os.Exit(1)
		}

		w := tabwriter.NewWriter(os.Stdout, 0, 8, 1, '\t', 0)
		fmt.Fprint(w, "ID\tURI\tDistribution\n")
		for _, repository := range repositories {
			fmt.Fprintf(w, "%d\t%s\t%s\n", repository.ID, repository.URI, repository.Distribution)
		}
		w.Flush()
	},
}

type RepositoryStatus struct {
	Changes []RepositoryChange
}

type RepositoryChange struct {
	PackageID    int64     `json:"package_id"`
	Component    string    `json:"component"`
	Package      string    `json:"package"`
	Version      string    `json:"version"`
	Architecture string    `json:"architecture"`
	UpdatedAt    time.Time `json:"updated_at"`
	Change       string    `json:"change"`
}

var statusRepositoryCmd = &cobra.Command{
	Use:   "status",
	Short: "Show status of a repository",
	Run: func(cmd *cobra.Command, args []string) {
		repoID, err := cmd.Flags().GetInt("repo-id")
		if err != nil {
			fmt.Printf("could not read --repo-id: %s\n", err)
			os.Exit(1)
		}

		req, err := http.NewRequest(http.MethodGet, fmt.Sprintf("/api/v0/repositories/%d", repoID), nil)
		if err != nil {
			fmt.Printf("could not create request for repository status: %s\n", err)
			os.Exit(1)
		}
		res, err := API(req)
		if err != nil {
			fmt.Printf("could not get repository status: %s\n", err)
			os.Exit(1)
		}
		defer res.Body.Close()

		if res.StatusCode != http.StatusOK {
			fmt.Printf("could not get repository status: %s\n", res.Status)
			os.Exit(1)
		}

		var status RepositoryStatus
		if err := json.NewDecoder(res.Body).Decode(&status); err != nil {
			fmt.Printf("could not decode repository: %s\n", err)
			os.Exit(1)
		}

		fmt.Println("Repository status:")
		w := tabwriter.NewWriter(os.Stdout, 0, 8, 1, '\t', 0)
		fmt.Fprint(w, "ID\tAction\tComponent\tPackage\tVersion\tArchitecture\tUpdated At\n")
		for _, change := range status.Changes {
			fmt.Fprintf(
				w,
				"%d\t%s\t%s\t%s\t%s\t%s\t%s\n",
				change.PackageID,
				change.Change,
				change.Component,
				change.Package,
				change.Version,
				change.Architecture,
				change.UpdatedAt,
			)
		}
		w.Flush()
	},
}

